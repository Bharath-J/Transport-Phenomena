#!/usr/bin/env python
## used to parse files more easily
#from __future__ import with_statement
import time
#
from pylab import *
ion()
from scipy import *
# os
import os
# Numpy module
import numpy as np
# for command-line arguments
import sys
# Qt4 bindings for core Qt functionalities (non-GUI)
from PyQt4 import QtCore
# Python Qt4 bindings for GUI objects
from PyQt4 import QtGui
# import the MainWindow widget from the converted .ui files
from qtdesigner import Ui_MplMainWindow
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s
class DesignerMainWindow(QtGui.QMainWindow, Ui_MplMainWindow):
  """Customization for Qt Designer created window"""
  def __init__(self, parent = None):
    # initialization of the superclass
    super(DesignerMainWindow, self).__init__(parent)
    # setup the GUI --> function generated by pyuic4
    self.setupUi(self)

  def clear(self):
    self.mpl.canvas.ax.clear()
    self.mpl.canvas.draw()

  def run(self):
    self.mpl.canvas.ax.clear()
    self.timemax = float(self.lineEdit_timemax.text())
    self.nx = int(self.lineEdit_nx.text())
    self.ny = int(self.lineEdit_ny.text())
    self.L  = float(self.lineEdit_L.text())
    self.D  = float(self.lineEdit_D.text())
    self.dx = self.L/(self.nx-1)
    self.dy = self.L/(self.ny-1)
    self.dt = 0.2*self.dx**2/self.D 
    self.x = arange(0., self.L+1.0e-12, self.dx)
    self.y = arange(0., self.L+1.0e-12, self.dy)
    self.c = zeros((self.nx, self.ny))
    laplacian = zeros((self.nx, self.ny))
    if self.radioButton_pointsource.isChecked():
      sigma = 0.1;
      for i in range(self.nx):
        for j in range(self.ny):
          self.c[i,j] = 1./sqrt(2*pi*sigma**2)*exp(-((self.x[i]-0.5)**2+(self.y[j]-0.5)**2)/(2*sigma**2))
    elif self.radioButton_step.isChecked():
      pass
    elif self.radioButton_cross.isChecked():
      for i in range(self.nx):
        for j in range(self.ny):
          if abs(self.x[i]-self.L/2)<0.1*self.L and abs(self.y[j]-self.L/2)<0.3*self.L:
            self.c[i,j] = 1.
          if abs(self.x[i]-self.L/2)<0.3*self.L and abs(self.y[j]-self.L/2)<0.1*self.L:
            self.c[i,j] = 1.
    self.mpl.canvas.ax.set_xlim(0.,self.L)
    self.mpl.canvas.ax.set_ylim(0.,self.L)
    cmin = 0.
    cmax = self.c.max()
    if self.radioButton_step.isChecked():
      cmax = 1.
    dc = cmax/30
    myplot = self.mpl.canvas.ax.contourf(self.x,self.y,self.c.transpose(),arange(0.,cmax+dc,dc))
    self.t = 0. 
    self.mpl.canvas.ax.set_title('t='+repr(self.t/self.L**2*self.D)+'$\\% of L^2/\\mathcal{D} $')
    self.mpl.canvas.draw()
    while (self.t<self.timemax):
      self.t = self.t+self.dt
      laplacian[1:-1,1:-1] = \
                  (self.c[2:,1:-1]-2*self.c[1:-1,1:-1]+self.c[:-2,1:-1])/self.dx**2 + \
                  (self.c[1:-1,2:]-2*self.c[1:-1,1:-1]+self.c[1:-1,:-2])/self.dy**2
      # periodicity in y
      laplacian[:,0] = laplacian[:,self.ny-2]
      laplacian[:,self.ny-1] = laplacian[:,1]
      # periodicity in x
      laplacian[0,:] = laplacian[self.nx-2,:]
      laplacian[self.nx-1,:] = laplacian[1,:]
      if self.radioButton_step.isChecked():
        laplacian[0,:] = 0.
        laplacian[self.nx-1,:] = 0.
      self.c = self.c + self.dt*self.D*laplacian
      if self.radioButton_step.isChecked():
        self.c[0,:] = 1.
      # update plot
      #self.myplot.set_array(self.c.ravel())
      self.clear()
      myplot = self.mpl.canvas.ax.contourf(self.x,self.y,self.c.transpose(),arange(0.,cmax+dc,dc))
      self.mpl.canvas.ax.set_title('t='+format(self.t/self.L**2*self.D*100,'6.2f')+'% of $L^2/\\mathcal{D}$')
      self.mpl.canvas.draw()
      QtCore.QCoreApplication.processEvents()

  def stop(self):
    self.t = self.timemax

# create the GUI application
app = QtGui.QApplication(sys.argv)
# instantiate the main window
dmw = DesignerMainWindow()
# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
sys.exit(app.exec_())

